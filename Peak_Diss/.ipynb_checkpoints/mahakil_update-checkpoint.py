# -*- coding: utf-8 -*-
"""MAHAKIL_UPDATE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JbafWT63OrBcRbahyx5kJn5kw12_5URO
"""

# MAHAKIL resampling
# phase 1: Calculate Mahalanobis distance and sort descending
# phase 2: partition
# phase 3: Synthesize new samples
import numpy as np
import time

class SingularMatrixException(Exception):
    def __init__(self):
        Exception.__init__(self,"Singular data matrix... use subspace") 

class MAHAKIL(object):
    def __init__(self, pfp=0.5):
        self.data_t = None  # Save the initial defect sample
        self.pfp = pfp  # Proportion of expected defect samples
        self.T = 0  # Number of defect samples to be generated
        self.new = []  # Store newly generated samples

    # Core method
    # return : data_new, label_new
    def fit_sample(self, data, label):
        # data: sample array containing metric information
        # label: sample label array
        data_t, data_f, label_t, label_f = [], [], [], []
        # Divide the data set according to positive examples and negative examples
        for i in range(label.shape[0]):
            if label[i] == 1:
                data_t.append(data[i])
                label_t.append(label[i])
            if label[i] == 0:
                data_f.append(data[i])
                label_f.append(label[i])
        self.T = len(data_f) / (1 - self.pfp) - len(data_f)
        self.data_t = np.array(data_t)
        print('sorted data')
        # Calculate the Mahalanobis distance
        d = self.mahalanobis_distance(self.data_t)
        print('calculated distance')
        # Descending order
        d.sort(key=lambda x: x[1], reverse=True)
        # Divide the set of positive examples into two
        k = len(d)
        d_index = [d[i][0] for i in range(k)]
        data_t_sorted = [data_t[i] for i in d_index]
        mid = int(k/2)
        bin1 = [data_t_sorted[i] for i in range(0, mid)]
        bin2 = [data_t_sorted[i] for i in range(mid, k)]
        # Loop iteration to generate new samples
        l_ = len(bin1)
        mark = [1, 3, 7, 15, 31, 63, 127, 255, 511]
        p = self.T / l_
        is_full = True
        g = mark.index([m for m in mark if m > p][0]) + 1
        cluster = 2 ** (g - 1)  # Number of children of the last generation
        if (self.T - mark[g-2]*l_) < cluster:
            # Explain that adding more generations is better than keeping a few
            is_full = False
            g -= 1
            k = 0
        else:
            k = l_ - round((self.T - mark[g-2]*l_)/cluster)
        self.generate_new_sample(bin1, bin2, g, l_, k, is_full)
        # Return data and labels
        label_new = np.ones(len(self.new))
        return np.append(data, self.new, axis=0), np.append(label, label_new, axis=0)

    def mahalanobis_distance(self, x):
        # x: array
        mu = np.mean(x, axis=0)  # Mean
        d = []
        for i in range(x.shape[0]):
            x_mu = np.atleast_2d(x[i] - mu)
            s = self.cov(x)
            d_squre = np.dot(np.dot(x_mu, np.linalg.inv(s)), np.transpose(x_mu))[0][0]
            d_tuple = (i, d_squre)
            d.append(d_tuple)
        return d

    @staticmethod
    def cov(x):
        # x: array
        s = np.zeros((x.shape[1], x.shape[1]))
        mu = np.mean(x, axis=0)  # Mean
        for i in range(x.shape[0]):
            x_xbr = np.atleast_2d(x - mu)
            s_i = np.dot(np.transpose(x_xbr), x_xbr)
            s = s + s_i
        return np.divide(s, x.shape[0])

    # Generate new samples
    def generate_new_sample(self, bin1, bin2, g, l, k, is_full):
        # bin1, bin2 are arrays
        # g Hereditary remaining algebra
        # l bin1 number of items
        # k The number of each node to be cropped in the last generation
        # is_full whether it overflows, that is, the last generation is counted, whether it exceeds T, or is not full
        assert len(bin1) <= len(bin2)
        if g >= 2 or (g == 1 and is_full is False):
            print('reached')
            lv_0 = []  # Offspring
            for i in range(l):
                # Generate children
                lv_0.append(np.mean(np.append(np.atleast_2d(bin1[i]), np.atleast_2d(bin2[i]), axis=0), axis=0))
            self.new.extend(lv_0)
            self.generate_new_sample(lv_0, bin1, g-1, l, k, is_full)
            self.generate_new_sample(lv_0, bin2, g-1, l, k, is_full)
        if g == 1 and is_full:
            lv_0 = []  # Offspring
            for i in range(l):
                # Generate children
                lv_0.append(np.mean(np.append(np.atleast_2d(bin1[i]), np.atleast_2d(bin2[i]), axis=0), axis=0))
            del lv_0[-1: (-k-1): -1]
            self.new.extend(lv_0)