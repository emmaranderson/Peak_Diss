# -*- coding: utf-8 -*-
"""MAHAKIL_UPDATE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JbafWT63OrBcRbahyx5kJn5kw12_5URO
"""

# MAHAKIL resampling
# phase 1: Calculate Mahalanobis distance and sort descending
# phase 2: partition
# phase 3: Synthesize new samples
import numpy as np
import time
import pandas as pd

class SingularMatrixException(Exception):
    def __init__(self):
        Exception.__init__(self,"Singular data matrix... use subspace") 

class MAHAKIL(object):
    def __init__(self, pfp=0.5):
        self.data_t = None  # Save the initial defect sample
        self.pfp = pfp  # Proportion of expected defect samples
        self.T = 0  # Number of defect samples to be generated
        self.new = []  # Store newly generated samples

    # Core method
    # return : data_new, label_new
    def fit_sample(self, data, label):
        
        label = label.reset_index(drop=True)
        data = data.reset_index(drop=True)
        
        label_f = np.array(label[label==0])
        label_t = np.array(label[label==1])
        
        data_f = np.array(data[label==0])
        data_t = np.array(data[label==1])
        
        data_t = data_t+0.00001*np.random.rand((data_t.shape)[0],(data_t.shape)[1])
  
        self.T = len(data_f) / (1 - self.pfp) - len(data_f)
        self.data_t = np.array(data_t)
        print('sorted data')
        # Calculate the Mahalanobis distance
        d = self.mahalanobis_distance(self.data_t)
        
        d = pd.DataFrame (d,columns=['Malhabonis Distance'])
        d = d.reset_index(drop=False)
        d = d.values.tolist()
        
        print('calculated distance')
        # Descending order
        d.sort(key=lambda x: x[1], reverse=True)
        # Divide the set of positive examples into two
        k = len(d)
        d_index = [d[i][0] for i in range(k)]
        d_index = [ int(d) for d in d_index ]
        data_t_sorted = [data_t[i] for i in d_index]
        mid = int(k/2)
        bin1 = [data_t_sorted[i] for i in range(0, mid)]
        bin2 = [data_t_sorted[i] for i in range(mid, k)]
        # Loop iteration to generate new samples
        l_ = len(bin1)
        mark = [1, 3, 7, 15, 31, 63, 127, 255, 511]
        p = self.T / l_
        is_full = True
        g = mark.index([m for m in mark if m > p][0]) + 1
        cluster = 2 ** (g - 1)  # Number of children of the last generation
        if (self.T - mark[g-2]*l_) < cluster:
            # Explain that adding more generations is better than keeping a few
            is_full = False
            g -= 1
            k = 0
        else:
            k = l_ - round((self.T - mark[g-2]*l_)/cluster)
        self.generate_new_sample(bin1, bin2, g, l_, k, is_full)
        # Return data and labels
        label_new = np.ones(len(self.new))
        print(type(data))
        return np.append(data, self.new, axis=0), np.append(label, label_new, axis=0)

    def mahalanobis_distance(self, x):
        x_mu = x - np.mean(x)
        cov = np.cov(x.T)
        inv_covmat = np.linalg.inv(cov)
        left = np.dot(x_mu, inv_covmat)
        mahal = np.dot(left, x_mu.T).diagonal()
        return mahal


    # Generate new samples
    def generate_new_sample(self, bin1, bin2, g, l, k, is_full):
        # bin1, bin2 are arrays
        # g Hereditary remaining algebra
        # l bin1 number of items
        # k The number of each node to be cropped in the last generation
        # is_full whether it overflows, that is, the last generation is counted, whether it exceeds T, or is not full
        assert len(bin1) <= len(bin2)
        if g >= 2 or (g == 1 and is_full is False):
            print('reached')
            lv_0 = []  # Offspring
            for i in range(l):
                # Generate children
                lv_0.append(np.mean(np.append(np.atleast_2d(bin1[i]), np.atleast_2d(bin2[i]), axis=0), axis=0))
            self.new.extend(lv_0)
            self.generate_new_sample(lv_0, bin1, g-1, l, k, is_full)
            self.generate_new_sample(lv_0, bin2, g-1, l, k, is_full)
        if g == 1 and is_full:
            lv_0 = []  # Offspring
            for i in range(l):
                # Generate children
                lv_0.append(np.mean(np.append(np.atleast_2d(bin1[i]), np.atleast_2d(bin2[i]), axis=0), axis=0))
            del lv_0[-1: (-k-1): -1]
            self.new.extend(lv_0)
